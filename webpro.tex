\documentclass[uplatex,dvipdfmx]{jsarticle}
\usepackage[uplatex,deluxe]{otf} % UTF
\usepackage[noalphabet]{pxchfon} % must be after otf package
\usepackage{stix2} %欧文＆数式フォント
\usepackage[fleqn,tbtags]{mathtools} % 数式関連 (w/ amsmath)
\usepackage{hira-stix} % ヒラギノフォント＆STIX2 フォント代替定義（Warning回避）
\usepackage{booktabs}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{caption}
\captionsetup[lstlisting]{font={small,tt}}

\lstset{
basicstyle={\ttfamily},
identifierstyle={\small},
commentstyle={\smallitshape},
keywordstyle={\small\bfseries},
ndkeywordstyle={\small},
stringstyle={\small\ttfamily}, frame={tb},
breaklines=true, columns=[l]{fullflexible},
numbers=left, xrightmargin=0zw, xleftmargin=3zw,
numberstyle={\scriptsize}, stepnumber=1,
numbersep=1zw, lineskip=-0.5ex
}

\begin{document}
\title{期末レポート} %システム名 仕様書 という形式にする
\author{24G1089 武本龍}
\date{2024年7月21日}
\maketitle

\section{はじめに}
本レポートは,大きな文字を表示させたり,その大きさを２倍したりするプログラムをフローチャートや関数仕様書,さらに,
各自で作成した関数の設計経緯を用いながらプログラムを分かりやすく説明するものである.

\section{プログラムの概要}
今回作成したプログラムの概要を説明する.

\subsection{プログラムの関係}
プログラムの中身を紹介する前に,作成したファイルの処理を説明する.
今回用いたヘッダファイルとソースファイルは以下の図\ref{fig:ファイル説明}の通りである.

\begin{figure}[h]
    \centering
    \includegraphics[width=13cm]{./Figs/プレゼンテーション1_1.pdf}
    \caption{ファイル説明}
    \label{fig:ファイル説明}
\end{figure}
 
自作関数を内包するファイルから「bigLetter.c」を説明のために使用する.今回用いたヘッダファイル「mul2.h」では関数や変数を宣言し,
main関数を内包しない「mul2.c」では「mul2.h」で宣言された関数の処理内容を記述し,
main関数を内包する「bigLetter.c」では実装された関数を呼び出し実行するという関係である.
「bigLetter.c」の部分は自作関数を内包するファイル全てに当てはまる.

\subsection{全体のフローチャート}
上記のことをフローチャートでより分かりやすくした.
\begin{figure}[h]
    \centering
    \includegraphics[width=17cm]{./Figs/プレゼンテーション3.pdf}
    \caption{全体のフローチャート}
    \label{fig:全体のフローチャート}
\end{figure}

標準ライブラリとヘッダファイルをインクルードしたら自作関数を内包するファイルの中のmain関数から自作関数を呼び出し,その関数を実行し,戻り値は0で処理を終えるという流れである.

\subsection{関数の仕様書}
自作関数とその関数の仕様は以下の表の通りである.
\newpage

\begin{table}[h]
    \centering
    \caption{関数の仕様書}
    \begin{tabular}{@{}lcc@{}}
    \toprule
    \textbf{関数名}         & \textbf{関数仕様}                                        \\ \midrule
    \textbf{bigLetter}                & 大きな文字を表示   \\ 
    \textbf{multipleLettersWidth}               &     複数の文字を横に並べる                                \\ 
    \textbf{multipleLettersLength}             &      複数の文字を縦に並べる                        \\ 
    \textbf{width2x}                &     横２倍の大きさで表示                     \\ 
    \textbf{length2x}                & 縦２倍の大きさで表示                              \\ 
    \textbf{widthLength2x}                & 縦横２倍の大きさで表示                             \\ 
    \textbf{bold}                & 太字の装飾                          \\ \bottomrule
  \end{tabular}
\end{table}

さらに詳しく関数を説明する.

\subsubsection{bigLetter関数}
bigLetter関数について詳しく説明する.以下の表2はbigLetter関数のドキュメントである.
\begin{table}[h]
    \centering
    \caption{bigLetter関数のドキュメント}
    \begin{tabular}{@{}lcc@{}}
    \toprule
    \textbf{関数名}         & \textbf{bigLetter}                                        \\ \midrule
    \textbf{関数の内容}                & 2次元配列pattern内の0は空白として,1はXとして出力する\\ 
    \textbf{パラメーターの数}               &     なし                                \\ 
    \textbf{与えるべき情報}             &     なし                        \\ 
    \textbf{型}                &     int型                    \\ 
    \textbf{戻り値}                & 0                              \\ \bottomrule
  \end{tabular}
\end{table}

以下の図\ref{fig:bigLetter関数のフローチャート}にbigLetter関数のフローチャートを示す.
\newpage
\begin{figure}[h]
    \centering
    \includegraphics[width=13cm]{./Figs/プレゼンテーション4.pdf}
    \caption{bigLetter関数のフローチャート}
    \label{fig:bigLetter関数のフローチャート}
\end{figure}

また,以下にbigLetter関数のソースコードを示す.
\begin{lstlisting}[firstnumber = 1, caption=大きな文字を表示する, label=code]   
int bigLetter(){
    int pattern[][8] = {
        { 0, 0, 0, 1, 1, 0, 0, 0 },
        { 0, 0, 1, 0, 0, 1, 0, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 1, 1, 1, 1, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0 }
        };
    
    int len_x = sizeof(pattern[0]) / sizeof(int);
    int len_y = sizeof(pattern) / len_x / sizeof(int);
    
    for( int y=0; y<len_y; y++ ) {
        for( int x=0; x<len_x; x++ ) {
            if( pattern[y][x] == 0 ) printf(" ");
            else printf("X");
        }
        printf("\n");
    }
    return 0;
}
\end{lstlisting}

\subsubsection{multipleLettersWidth関数}
multipleLettersWidth関数について詳しく説明する.以下の表3はmultipleLettersWidth関数のドキュメントである.
\begin{table}[h]
    \centering
    \caption{multipleLettersWidth関数のドキュメント}
    \begin{tabular}{@{}lcc@{}}
    \toprule
    \textbf{関数名}         & \textbf{multipleLettersWidth}                                        \\ \midrule
    \textbf{関数の内容}                & 3次元配列pattern内の0は空白として,1はXとして横並びに出力する \\ 
    \textbf{パラメーターの数}               &     なし                                \\ 
    \textbf{与えるべき情報}             &     なし                        \\ 
    \textbf{型}                &     int型                    \\ 
    \textbf{戻り値}                & 0                              \\ \bottomrule
  \end{tabular}
\end{table}

以下の図\ref{fig:multipleLettersWidth関数のフローチャート}にmultipleLettersWidth関数のフローチャートを示す.
\begin{figure}[h]
    \centering
    \includegraphics[width=13cm]{./Figs/プレゼンテーション5.pdf}
    \caption{multipleLettersWidth関数のフローチャート}
    \label{fig:multipleLettersWidth関数のフローチャート}
\end{figure}

また,以下にmultipleLettersWidth関数のソースコードを示す.
\begin{lstlisting}[firstnumber = 1, caption=複数の文字を横に並べる, label=code]   
int multipleLettersWidth(){
    int pattern[][8][8] = {
        {
            { 0, 0, 0, 1, 1, 0, 0, 0 },
            { 0, 0, 1, 0, 0, 1, 0, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 1, 1, 1, 1, 1, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
            { 1, 1, 1, 1, 1, 1, 0, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 1, 1, 1, 1, 0, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 1, 1, 1, 1, 1, 1, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0 }
        }
    };

    int len_x = sizeof(pattern[0][0]) / sizeof(int);
    int len_y = sizeof(pattern[0]) / len_x / sizeof(int);
    int len_z = sizeof(pattern) / len_x / len_y / sizeof(int);
    
    for (int y = 0; y < len_y; y++){
            for (int p = 0; p < len_z; p++){
                for (int x = 0; x < len_x; x++){
                    if (pattern[p][y][x] == 0)
                    printf(" ");
                    else
                    printf("X");
                    }
                printf("  ");  // パターン間のスペース
            }
            printf("\n");
        }
    return 0;
}
\end{lstlisting}

\subsubsection{multipleLettersLength関数}
multipleLettersLength関数について詳しく説明する.以下の表4はmultipleLettersLength関数のドキュメントである.
\newpage
\begin{table}[h]
    \centering
    \caption{multipleLettersLength関数のドキュメント}
    \begin{tabular}{@{}lcc@{}}
    \toprule
    \textbf{関数名}         & \textbf{multipleLettersLength}                                        \\ \midrule
    \textbf{関数の内容}                &    3次元配列pattern内の0は空白として,1はXとして縦並びに出力する\\
    \textbf{パラメーターの数}               &     なし                                \\ 
    \textbf{与えるべき情報}             &     なし                        \\ 
    \textbf{型}                &     int型                    \\ 
    \textbf{戻り値}                & 0                              \\ \bottomrule
  \end{tabular}
\end{table}

以下の図\ref{fig:multipleLettersWidth関数のフローチャート}にmultipleLettersLength関数のフローチャートを示す.
\begin{figure}[h]
    \centering
    \includegraphics[width=13cm]{./Figs/プレゼンテーション4_1.pdf}
    \caption{multipleLettersLength関数のフローチャート}
    \label{fig:multipleLettersLength関数のフローチャート}
\end{figure}

また,以下にmultipleLettersLength関数のソースコードを示す.
\begin{lstlisting}[firstnumber = 1, caption=複数の文字を縦に並べる, label=code]   
int multipleLettersLength(){
    int pattern[][8][8] = {
        {
            { 0, 0, 0, 1, 1, 0, 0, 0 },
            { 0, 0, 1, 0, 0, 1, 0, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 1, 1, 1, 1, 1, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0 }
        }, {
            { 1, 1, 1, 1, 1, 1, 0, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 1, 1, 1, 1, 0, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 0, 1, 0, 0, 0, 0, 1, 0 },
            { 1, 1, 1, 1, 1, 1, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0 }
        }
    };

    int len_x = sizeof(pattern[0][0]) / sizeof(int);
    int len_y = sizeof(pattern[0]) / len_x / sizeof(int);
    int len_z = sizeof(pattern) / len_x / len_y / sizeof(int);

    for( int y=0; y<len_y; y++ ) {
        for( int x=0; x<len_x; x++ ) {
            if( pattern[0][y][x] == 0 ) 
            printf(" ");
            else printf("X");
        }
        printf("\n");
    }

    for( int y=0; y<len_y; y++ ) {
        for( int x=0; x<len_x; x++ ) {
            if( pattern[1][y][x] == 0 ) 
                printf(" ");
            else
                printf("X");
        }
        printf("\n");
    }
    return 0;
}
\end{lstlisting}

\subsubsection{width2x関数}
width2x関数について詳しく説明する.以下の表5はwidth2x関数のドキュメントである.
\newpage
\begin{table}[h]
    \centering
    \caption{width2x関数のドキュメント}
    \begin{tabular}{@{}lcc@{}}
    \toprule
    \textbf{関数名}         & \textbf{width2x}                                        \\ \midrule
    \textbf{関数の内容}                & 2次元配列pattern内の0は空白として,1はXとして横方向に2倍の幅で拡大して出力する\\ 
    \textbf{パラメーターの数}               &     なし                                \\ 
    \textbf{与えるべき情報}             &     なし                        \\ 
    \textbf{型}                &     int型                    \\ 
    \textbf{戻り値}                & 0                              \\ \bottomrule
  \end{tabular}
\end{table}

以下の図\ref{fig:width2x関数のフローチャート}にwidth2x関数のフローチャートを示す.
\begin{figure}[h]
    \centering
    \includegraphics[width=13cm]{./Figs/プレゼンテーション4_3.pdf}
    \caption{width2x関数のフローチャート}
    \label{fig:width2x関数のフローチャート}
\end{figure}

また,以下にwidth2x関数のソースコードを示す.
\begin{lstlisting}[firstnumber = 1, caption=横２倍の大きさで表示する, label=code]   
int width2x(){
    int pattern[][8] = {
        { 0, 0, 0, 1, 1, 0, 0, 0 },
        { 0, 0, 1, 0, 0, 1, 0, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 1, 1, 1, 1, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0 }
    };
        
    int len_x = sizeof(pattern[0]) / sizeof(pattern[0][0]);
    int len_y = sizeof(pattern) / sizeof(pattern[0]);
    // パターンを2倍の横幅で出力
    for (int y = 0; y < len_y; y++) {
        for (int h = 0; h < 1; h++) { // 高さ(high)
            for (int x = 0; x < len_x; x++) {
                for (int w = 0; w < 2; w++) { // 横方向に2倍(width)
                    if (pattern[y][x] == 0) 
                        printf(" ");
                    else
                        printf("X");
                }
            }
            printf("\n");
        }
    }
    return 0;
}
\end{lstlisting}

\subsubsection{length2x関数}
length2x関数について詳しく説明する.以下の表6はlength2x関数のドキュメントである.

\begin{table}[h]
    \centering
    \caption{length2x関数のドキュメント}
    \begin{tabular}{@{}lcc@{}}
    \toprule
    \textbf{関数名}         & \textbf{length2x}                                        \\ \midrule
    \textbf{関数の内容}                & 2次元配列pattern内の0は空白として,1はXとして縦方向に2倍の幅で拡大して出力する   \\ 
    \textbf{パラメーターの数}               &     なし                                \\ 
    \textbf{与えるべき情報}             &     なし                        \\ 
    \textbf{型}                &     int型                    \\ 
    \textbf{戻り値}                & 0                              \\ \bottomrule
  \end{tabular}
\end{table}

以下の図\ref{fig:length2x関数のフローチャート}にlength2x関数のフローチャートを示す.
\newpage
\begin{figure}[h]
    \centering
    \includegraphics[width=13cm]{./Figs/プレゼンテーション4_4.pdf}
    \caption{length2x関数のフローチャート}
    \label{fig:length2x関数のフローチャート}
\end{figure}

また,以下にlength2x関数のソースコードを示す.
\begin{lstlisting}[firstnumber = 1, caption=縦２倍の大きさで表示する, label=code] 
int length2x(){
    int pattern[][8] = {
        { 0, 0, 0, 1, 1, 0, 0, 0 },
        { 0, 0, 1, 0, 0, 1, 0, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 1, 1, 1, 1, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0 }
    };
        
    int len_x = sizeof(pattern[0]) / sizeof(pattern[0][0]);
    int len_y = sizeof(pattern) / sizeof(pattern[0]);
    
    // パターンを2倍の横幅で出力
    for (int y = 0; y < len_y; y++) {
        for (int h = 0; h < 2; h++) { // 高さ(high)
            for (int x = 0; x < len_x; x++) {
                for (int w = 0; w < 1; w++) { // 横方向に2倍(width)
                    if (pattern[y][x] == 0)
                        printf(" ");
                    else
                        printf("X");
                }
            }
            printf("\n");
        }
    }
    return 0;
}
\end{lstlisting}

\subsubsection{widthLength2x関数}
widthLength2x関数について詳しく説明する.以下の表7はwidthLength2x関数のドキュメントである.

\begin{table}[h]
    \centering
    \caption{関数のドキュメント}
    \begin{tabular}{@{}lcc@{}}
    \toprule
    \textbf{関数名}         & \textbf{widthLength2x}                                        \\ \midrule
    \textbf{関数の内容}                & 2次元配列pattern内の0は空白として,1はXとして縦横両方向に2倍の幅で拡大して出力する\\ 
    \textbf{パラメーターの数}               &     なし                                \\ 
    \textbf{与えるべき情報}             &     なし                        \\ 
    \textbf{型}                &     int型                    \\ 
    \textbf{戻り値}                & 0                              \\ \bottomrule
  \end{tabular}
\end{table}

以下の図\ref{fig:widthLength2x関数のフローチャート}にwidthLength2x関数のフローチャートを示す.
\begin{figure}[h]
    \centering
    \includegraphics[width=13cm]{./Figs/プレゼンテーション4_5.pdf}
    \caption{widthLength2x関数のフローチャート}
    \label{fig:widthLength2x関数のフローチャート}
\end{figure}

また,以下にwidthLength2x関数のソースコードを示す.
\begin{lstlisting}[firstnumber = 1, caption=縦横２倍の大きさで表示する, label=code]
int widthLength2x() {
    int pattern[][8] = {
        { 0, 0, 0, 1, 1, 0, 0, 0 },
        { 0, 0, 1, 0, 0, 1, 0, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 1, 1, 1, 1, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0 }
    };

    int len_x = sizeof(pattern[0]) / sizeof(int);
    int len_y = sizeof(pattern) / len_x / sizeof(int);

    for (int y = 0; y < len_y; y++) {
        for (int h = 0; h < 2; h++) { 
            for (int x = 0; x < len_x; x++) {
                for (int w = 0; w < 2; w++) { 
                    if (pattern[y][x] == 0) 
                        printf(" ");
                    else 
                        printf("X");
                }
            }
            printf("\n");
        }
    }
    return 0;
}
\end{lstlisting}

\subsubsection{bold関数}
bold関数について詳しく説明する.以下の表8はbold関数のドキュメントである.
\begin{table}[h]
    \centering
    \caption{関数のドキュメント}
    \begin{tabular}{@{}lcc@{}}
    \toprule
    \textbf{関数名}         & \textbf{bold}                                        \\ \midrule
    \textbf{関数の内容}                &  2次元配列pattern内の0は空白として,1は太字のXとして出力する  \\ 
    \textbf{パラメーターの数}               &     なし                                \\ 
    \textbf{与えるべき情報}             &     なし                        \\ 
    \textbf{型}                &     int型                    \\ 
    \textbf{戻り値}                & 0                              \\ \bottomrule
  \end{tabular}
\end{table}

以下の図\ref{fig:bold関数のフローチャート}にbold関数のフローチャートを示す.
\newpage
\begin{figure}[h]
    \centering
    \includegraphics[width=13cm]{./Figs/プレゼンテーション5_1.pdf}
    \caption{bold関数のフローチャート}
    \label{fig:bold関数のフローチャート}
\end{figure}

また,以下にbold関数のソースコードを示す.
\begin{lstlisting}[firstnumber = 1, caption=太字の装飾をつける, label=code]
int bold(){
    int pattern[][8] = {
        { 0, 0, 0, 1, 1, 0, 0, 0 },
        { 0, 0, 1, 0, 0, 1, 0, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 1, 1, 1, 1, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 1, 0, 0, 0, 0, 1, 0 },
        { 0, 0, 0, 0, 0, 0, 0, 0 }
    };

    int len_x = sizeof(pattern[0]) / sizeof(int);
    int len_y = sizeof(pattern) / len_x / sizeof(int);

    for( int y=0; y<len_y; y++ ) {
        for( int x=0; x<len_x; x++ ) {
            if( pattern[y][x] == 0 ) printf(" ");
            else { 
                printf("\e[1m"); // 太字テキストを開始
                printf("X");
                printf("\e[0m"); // 太字テキストを終了
            }
        }
        printf("\n");
    }
    return 0;
}
\end{lstlisting}

\section{分割コンパイル方法}
分割コンパイルの仕方について説明する.分割コンパイル法は以下の通りである.
\begin{lstlisting}[firstnumber = 1, caption=分割コンパイル法, label=code]


\end{lstlisting}

\section{設計経緯について}
main関数内をできるだけ書かないという条件が提示されたので,実行ファイル「mul2.c」,ヘッダファイル「mul2.h」及び実装された関数を呼び出し実行するファイル7つに分割した.
分割するとファイル間を繋ぐためのインクルードが必要になるので,そのやり方について詳しく調べ,実行できるようにした.
また,自作関数を呼び出しする7つの実行ファイルには,それぞれがなにをするのかという特徴を明確にし分かりやすなった.
例えば,「複数の文字を横に並べる」という関数の場合は,ファイルは,関数はmultipleLettersWidthとしている.

授業中にできなかったものや間違えていた内容について再度理解し,プログラムに落とし込んだ

\end{document}